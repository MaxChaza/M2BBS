<html>
<head><title>HowTo write a Charlie-Plugin</title></head>

<h1 align="left">HowTo write a Charlie-Plugin</h1>

In order to write a plugin for Charlie, there are some classes that need to be written.
It is possible to add new analyzers, rule sets, dialogs and command line options.
Step by step we will go through the process of writing a complete new plugin.
<p></p>

A plugin is a collection of java-classes that are collected in a jar- or in a zip-file.
If an additional library is needed that is not provided by Charlie then it is possible
to add the external library to a lib-directory (in the jar/zip-file), i.e.,
add a directory <code>lib</code> to the jar/zip-file and there add any wanted library.
Please have a closer look to the corresponding section if you need to add an external library to the plugin.



<h1 align="left">Writing a new Analyzer</h1>

In order to write a new Analyzer for Charlie, one has to extend the class
<code>charlie.plugin.analyzer.PluginAnalyzer</code>.
There are some functions that must be written (all the abstract functions)
and there are some functions that are recommended to be overwritten.
<p></p>

The following functions are abstract and thus have to be overwritten:
<ul>
<li><code>public String getName()</code> Returns the name of the analyzer. This name is also shown in the thread frame.
    The thread frame is the frame that is, by default, shown on the right hand side when an analyzer is started. </li>
<li><code>public boolean registerAnalyzer()</code> Registers the analyzer to the AnalyzerManager.
    For more information about the AnalyzerManager please have a look into the diploma thesis of Franzke. </li>
<li><code>public void analyze()</code> Here comes the important code of the analyzer.
    For more information on this topic please have a look into the diploma thesis of Franzke. </li>
<li><code>public void cleanup()</code> If the analysis is cancelled the analyzer can use this function to do some clean up.
    For more information on this topic please have a look into the diploma thesis of Franzke. </li>
<li><code>protected void evaluate()</code> After the analysis the analyzer is given the chance to evaluate its work.
    For more information on this topic please have a look into the diploma thesis of Franzke. </li>
<li><code>public Analyzer getNewInstance(OptionSet options)</code> Returns a new analyzer that is initialized by the given option set.
    For more information on this topic please have a look into the diploma thesis of Franzke. </li>
<li><code>public void initializeInfoStrings()</code> Returns statistic information.
    For more information on this topic please have a look into the diploma thesis of Franzke. </li>
</ul>


The next few functions need to be overwritten if the analyzer shall be able to be called by the command line.
If the analyzer should only be accessable by the GUI one can ignore the next few functions.
Their default behavior is to tell the user that the analyzer is not accessable via the command line. 

<ul>
<li><code>public PluginOptionSet setupPluginOptionSet(PlaceTransitionNet _pn)</code> 
    Sets up a new options set. This is done during the initialization of the analyzer.
    The analyzer itself is responsible for setting up the OptionSet, i.e., especially
    the object to analyze and the result object must be set.
    Other options are setup in a later state and are directly given to the <code>OptionSet</code>. </li>
<li><code>public String[] invokedBy()</code> Returns an array containing the strings with that the analyzer can be invoked by the command line. </li>
</ul>



<h1 align="left">Writing a new Rule Set Extension</h1>

To extend the rule sets it is necessary to write a <code>charlie.plugin.analyzer.PluginRuleExtender</code>.
A rule in the sense of Charlie are some implications from properties that have been analyzed by Charlie.
<p></p>

There are only the next two functions that can be overwritten.
None of them is marked as abstract so it is arbitrary to extend these functions.
<ul>
<li><code>public List<Rule> getAdditionalRules()</code> Returns a list of new rules that will be added to the ResultManager.
    The default behavior is, that an empty list is returned, i.e., no new rule will be added.
    The rules are added at the startup phase. </li>
<li><code>public List<PluginResult> getAddionionalResults()</code> Returns a list of new results that are shown in the NetPropertiesDialog panel.
    The properties in the list must be unique, i.e., there must not be another property with the same name
    in the standard property set as well as in any other plugin the user uses. </li>
</ul>




<h1 align="left">Adding External Libraries to the Plugin</h1>

In order to add an external library to the plugin, one simply has to add the library to the <code>lib</code> directory in the plugin file.
That's all.
The class loader is trying to load the classes in the libraries if necessary.
<p></p>

Note: currently there are no mechanisms to ensure that a specific library is loaded.
This could lead to a problem if a specific version of a library is needed and there are several plugins all providing the library.
Then it is not determined which library is loaded, since every class is loaded only once.
We expect that there are only small cases for that this leads to serious problems.
If this behavior is leading to a problem please contact us, then the chances increase that we think of a mechanism that solves this problem
in general.
Otherwise the chances are pretty low that this problem will be fixed.



</html>
